/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <pthread.h>
#include <stdio.h>
#include "bakery.h"

#define MAX_CONNECTION 100

static BAKERY ebuf_wrong_id           = {0, 0, 0, ERROR_WRONG_ID_RPC};
static BAKERY ebuf_incompatible_hanle = {0, 0, 0, ERROR_INCOMPATIBLE_HANLE_RPC};
static BAKERY ebuf_wrong_status       = {0, 0, 0, ERROR_WRONG_STATUS_RPC};
static BAKERY ebuf_reject_access      = {0, 0, 0, ERROR_REJECT_ACCESS_RPC};
static BAKERY ebuf_wrong_op           = {0, 0, 0, ERROR_WRONG_OP_RPC};

typedef struct
{
    BAKERY buffer;
    pthread_t thread;
    int status;
    BAKERY status_buffer;
} call_status_t;

static size_t call = 0;

static call_status_t handles[MAX_CONNECTION] = {{0, 0, 0, 0}, 0, STATUS_FREE};

static char   choosing[MAX_CONNECTION] = {0};
static size_t num[MAX_CONNECTION] = {0};
static size_t last = 0;
static int    out = 0;

static size_t in_critical = 0;
static char   critical = 0;

BAKERY *register_client(BAKERY *arg)
{
    while (num[last] && choosing[last] && STATUS_FREE != handles[last].status)
        if (++last == MAX_CONNECTION)
            last = 0;

    int i = last++;

    choosing[i] = 1;
    int max = 0;

    for (size_t j = 0; j < MAX_CONNECTION; j++)
        if (num[j] > max)
            max = num[j];

    num[i] = max + 1;
    choosing[i] = 0;

    handles[i].buffer.op = arg->op;
    handles[i].buffer.id = i;
    handles[i].buffer.num = num[i];
    handles[i].buffer.result = 0;
    handles[i].status = STATUS_REGISTERED;

    return &handles[i].buffer;
}

void *access_client_thread(void *_arg)
{
    call_status_t *carg = _arg;
    BAKERY *arg = &carg->buffer;

    for (size_t i = 0; i < MAX_CONNECTION; i++)
    {
        while (choosing[i]);
        while (num[i]
               && (num[i] < num[arg->id]
                   || (num[i] == num[arg->id] && i < arg->id)));
    }

    critical = 1;
    in_critical = arg->id;
    carg->status = STATUS_READY_FOR_CR;

    return arg;
}

BAKERY *access_client(BAKERY *arg)
{
    pthread_t thread;

    if (arg->id < 0 || arg->id >= MAX_CONNECTION)
        return &ebuf_wrong_id;

    if (arg->num != num[arg->id])
        return &ebuf_incompatible_hanle;

    if (STATUS_REGISTERED != handles[arg->id].status)
        return &ebuf_wrong_status;

    handles[arg->id].status = STATUS_ACCESSING;
    handles[arg->id].buffer = *arg;

    if (pthread_create(&thread, NULL, access_client_thread, &handles[arg->id]) != EXIT_SUCCESS)
    {
        perror("pthread_create error\n");
        exit(EXIT_FAILURE);
    }

    handles[arg->id].thread = thread;

    return &handles[arg->id].buffer;
}

BAKERY *get_client(BAKERY *arg)
{
    if (arg->id < 0 || arg->id >= MAX_CONNECTION)
        return &ebuf_wrong_id;

    if (arg->num != num[arg->id])
        return &ebuf_wrong_status;

    if (!critical)
        return &ebuf_reject_access;

    if (arg->id != in_critical)
        return &ebuf_reject_access;

    if (STATUS_READY_FOR_CR != handles[arg->id].status)
        return &ebuf_wrong_status;

    if (pthread_join(handles[arg->id].thread, NULL) != EXIT_SUCCESS)
    {
        perror("pthread_join error\n");
        exit(EXIT_FAILURE);
    }

    handles[arg->id].buffer = *arg;
    handles[arg->id].buffer.result = out++;

    if (out < 0)
        out = 0;

    handles[arg->id].status = STATUS_FREE;
    num[arg->id] = 0;
    critical = 0;

    return &handles[arg->id].buffer;
}

BAKERY *status_client(BAKERY *arg)
{
    if (arg->id < 0 || arg->id >= MAX_CONNECTION)
        return &ebuf_wrong_id;

    handles[arg->id].status_buffer.result = handles[arg->id].status;

    return &handles[arg->id].status_buffer;
}

BAKERY *bakery_proc_1_svc(BAKERY *argp, struct svc_req *rqstp)
{
    if (argp->op < 0 && argp->op >= OP_MAX)
        return &ebuf_wrong_op;

    BAKERY *tmp = NULL;

    switch (argp->op)
    {
        case (REGISTER):
            printf("> New user\n");
            tmp = register_client(argp);
            printf("< User %d registered\n", tmp->id);
            break;
        case (ACCESS):
            printf("> User %d call\n", argp->id);
            tmp = access_client(argp);
            printf("< User %d entered queue\n", argp->id);
            break;
        case (GET):
            printf("> User %d call\n", argp->id);
            tmp = get_client(argp);
            printf("< User %d attempted to enter exclusive mode\n", argp->id);
            break;
        case (STATUS):
            printf("> User %d call\n", argp->id);
            tmp = status_client(argp);
            printf("< User %d accessed status\n", argp->id);
            break;
    }

    return tmp;
}

