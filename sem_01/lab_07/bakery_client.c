/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include <unistd.h>
#include "bakery.h"
#include "cli.h"

typedef struct
{
    BAKERY *bakery;
    CLIENT *clnt;
} handle_t;

void prompt(void *arg)
{
    if (arg)
        return;

    printf("[%d] $ ", getpid());
}

int register_client(const size_t n, char **args, void *arg)
{
    handle_t *bak_arg = arg;
    BAKERY *tmp;

    bak_arg->bakery->op = REGISTER;
    tmp = bakery_proc_1(bak_arg->bakery, bak_arg->clnt);

    if (tmp == (BAKERY *) NULL)
    {
        clnt_perror(bak_arg->clnt, "call failed");
        return EXIT_SUCCESS;
    }

    *bak_arg->bakery = *tmp;

    printf("Клиент зарегистрирован, номер: (%d)\n", bak_arg->bakery->num);

    return EXIT_SUCCESS;
}

int access_client(const size_t n, char **args, void *arg)
{
    handle_t *bak_arg = arg;
    BAKERY *tmp;

    bak_arg->bakery->op = ACCESS;
    tmp = bakery_proc_1(bak_arg->bakery, bak_arg->clnt);

    if (tmp == (BAKERY *) NULL)
    {
        clnt_perror(bak_arg->clnt, "call failed");
        return EXIT_SUCCESS;
    }

    if (0 > tmp->result)
    {
        printf("Ошибка при постановке в очередь\n");

        return EXIT_SUCCESS;
    }

    *bak_arg->bakery = *tmp;

    printf("Клиент помещен в очередь\n");

    return EXIT_SUCCESS;
}

int get_client(const size_t n, char **args, void *arg)
{
    handle_t *bak_arg = arg;
    BAKERY *tmp;

    bak_arg->bakery->op = GET;
    tmp = bakery_proc_1(bak_arg->bakery, bak_arg->clnt);

    if (tmp == (BAKERY *) NULL)
    {
        clnt_perror (bak_arg->clnt, "call failed");
        return EXIT_SUCCESS;
    }

    if (0 > tmp->result)
    {
        printf("Ошибка: невозможно получить доступ к критической области\n");

        return EXIT_SUCCESS;
    }

    *bak_arg->bakery = *tmp;
    printf("Значение: %d\n", bak_arg->bakery->result);

    return EXIT_SUCCESS;
}

int status_client(const size_t n, char **args, void *arg)
{
    handle_t *bak_arg = arg;
    BAKERY *tmp;

    bak_arg->bakery->op = STATUS;
    tmp = bakery_proc_1(bak_arg->bakery, bak_arg->clnt);

    if (tmp == (BAKERY *)NULL)
    {
        clnt_perror(bak_arg->clnt, "call failed");
        return EXIT_SUCCESS;
    }

    if (tmp->result < 0)
    {
        printf("Клиент еще не был создан\n");
        return EXIT_SUCCESS;
    }

    switch (tmp->result)
    {
        case (STATUS_FREE):
            printf("Клиент свободен\n");
            break;
        case (STATUS_REGISTERED):
            printf("Клиент зарегистрирован\n");
            break;
        case (STATUS_ACCESSING):
            printf("Клиент находится в очереди\n");
            break;
        case (STATUS_READY_FOR_CR):
            printf("Клиент может забрать значение\n");
            break;
        default:
            printf("Ошибка: неизвестное значение состояния\n");
            break;
    }

    return EXIT_SUCCESS;
}

void bakery_prog_1(char *host)
{
    CLIENT *clnt;
    BAKERY  bakery_proc_1_arg = {0, -1, 0, 0};
    handle_t handle;

#ifndef DEBUG
    clnt = clnt_create (host, BAKERY_PROG, BAKERY_VER, "udp");
    if (clnt == NULL) {
        clnt_pcreateerror (host);
        exit (1);
    }
#endif  /* DEBUG */
    handle.bakery = &bakery_proc_1_arg;
    handle.clnt = clnt;

    cli_t *cli = cli_init(NULL);

    cli_set_prompt(cli, prompt, NULL);

    cli_add_entry(cli, "register", "Получить номер\n", register_client, &handle);
    cli_add_entry(cli, "access", "Встать в очередь\n" , access_client, &handle);
    cli_add_entry(cli, "get", "Получить результат\n", get_client, &handle);
    cli_add_entry(cli, "status", "Получить состояние клиента\n", status_client, &handle);

    cli_mainloop(cli);

    cli_free(&cli);

#ifndef DEBUG
    clnt_destroy (clnt);
#endif   /* DEBUG */
}


int main (int argc, char *argv[])
{
    char *host;

    if (argc < 2) {
        printf ("usage: %s server_host\n", argv[0]);
        exit (1);
    }
    host = argv[1];
    bakery_prog_1 (host);
exit (0);
}
